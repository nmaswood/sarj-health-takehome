import { genAI, safetySettings } from "@/lib/gemini";
import {
  WoundAssessment,
  WoundAssessmentSchema,
} from "@/types/WoundAssessment";
import { NextResponse } from "next/server";

const systemContext = `You are a wound care specialist assistant providing personalized care instructions.
Your responses should be:
- Clear and empathetic, like speaking to a friend
- Uses analogies and simple explanations
- Balances professionalism with approachability
- Incorporates visual descriptions
- Makes complex medical concepts relatable

Format your responses using engaging markdown elements like:
- ðŸ“Œ for important points
- âš ï¸ for warnings
- âœ… for action items
- ðŸ” for monitoring tips
- â° for timing-related instructions
- ðŸ’¡ for helpful tips
- ðŸš« for things to avoid

Always maintain a caring, empathetic tone while being direct and clear.`;

const outputFormat = `
#Header# Assessment Summary (in bold, start here)
[Brief overview of wound type and risk level]

#Header2# Care Instructions(in bold)
#Header3# 1. Cleaning, Hygiene & Dressing Protocol (in bold)
- [Detailed steps, no more than 4]

#Header3# 2. Pain Management (in bold)
- [Detailed recommendations, no more than 3]

#Header3# 3. Warning Signs(in bold)
- [Key indicators, no more than 3]

#Header3# 5. Recovery Timeline(in bold)
- [One clear sentence]


---
*Medical Disclaimer: These instructions are generated by an AI assistant...*`;

const prompt = (woundDetails: string) => `
${systemContext}

Based on the following wound assessment, generate comprehensive care instructions following the specified format. 

${woundDetails}

Please structure your response according to this format:
${outputFormat}

Focus on making the instructions:
- Memorable
- Easy to follow
- Practical for real-life situations
- Encouraging and supportive
- Visual through descriptions
- Structured for quick reference

Additional requirements:
1. Tailor recommendations to the specific wound location and risk level
2. Include both immediate and long-term care instructions
3. Use conditional statements for different scenarios
4. Provide specific metrics where applicable (e.g., cleaning frequency)
5. Include emergency warning signs
6. Add lifestyle modifications based on wound location

Avoid:
- Greeting messages or starting with "Okay"
- Unnecessarily detailed instructions
- Generic advice without context
- Medical jargon without explanation
- Vague instructions
- Referring to the assessment data directly
`;

export async function POST(request: Request) {
  try {
    const parsedData: WoundAssessment = WoundAssessmentSchema.parse(
      await request.json(),
    );

    const woundDetails = `
      Wound Location: ${parsedData.location.site || "Unknown"}, ${parsedData.location.side || "Unknown"}
      Risk Level: ${parsedData.assessment.risk_level}
      Healing Status: ${parsedData.status.healing}
      Infection: ${parsedData.status.infection ? "Yes" : "No"}
      Pain Level: ${parsedData.status.pain}/10
      Exudate Level: ${parsedData.status.exudate}
      Estimated Healing Time: ${parsedData.assessment.estimated_healing_weeks} weeks
      Requires Debridement: ${parsedData.assessment.requires_debridement ? "Yes" : "No"}
    `;

    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

    const generationConfig = {
      maxOutputTokens: 2000,
      temperature: 0.7,
      topP: 0.8,
      topK: 40,
      presencePenalty: 0.6,
      frequencyPenalty: 0.3,
    };

    const chatSession = model.startChat({
      history: [],
      generationConfig,
      safetySettings,
    });

    const { stream: upstreamResponse } = await chatSession.sendMessageStream(
      prompt(woundDetails),
    );

    const stream = new ReadableStream({
      async start(controller) {
        try {
          for await (const chunk of upstreamResponse) {
            // Convert the chunk to text and enqueue it to the ReadableStream
            const chunkText = chunk.text();
            controller.enqueue(new TextEncoder().encode(chunkText));
          }
        } catch (error) {
          console.error("Error streaming data:", error);
          controller.error(error);
        } finally {
          controller.close();
        }
      },
    });

    return new NextResponse(stream, {
      headers: { "Content-Type": "text/event-stream" },
    });
    // return NextResponse.json({ careInstructions });
  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json(
      { error: "Invalid input or AI request failed." },
      { status: 400 },
    );
  }
}
